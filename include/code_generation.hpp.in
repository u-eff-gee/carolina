#pragma once

#include <iomanip>

using std::scientific;

#include <string>

using std::string;
using std::to_string;

#include <sstream>

using std::stringstream;

#include <vector>

using std::vector;

#include "branch.hpp"
#include "detector.hpp"

const string code_generation_dir = "@CMAKE_SOURCE_DIR@/code_generation/";
const string code_generation_output_dir = "@CMAKE_BINARY_DIR@/code_generation/";

string energy_branch(const Channel channel){
    return channel.energy_branch_name + "[" + to_string(channel.energy_branch_index) + "]";
}

string branch_registration(const vector<Branch> branches, const string indent = ""){
    string bra_reg = "";
    for(auto branch: branches){
        bra_reg = bra_reg + indent + "double " + branch.name + "[" + to_string(branch.n_leaves) + "];\n";
        if(branch.keep_previous){
            bra_reg = bra_reg + indent + "double previous_" + branch.name + "[" + to_string(branch.n_leaves) + "];\n";
        }
        bra_reg = bra_reg + indent + "tree->SetBranchAddress(\"" + branch.name + "\", " + branch.name + ");\n";
    }

    return bra_reg;
}

string coincidence_histogram_name(vector<DetectorGroup> detector_groups, Detector detector_0, Detector detector_1){
    string histogram_name;

    bool histogram_name_matched = false;
    for(size_t i = 0; i < detector_groups.size(); ++i){
        for(size_t j = i; j < detector_groups.size(); ++j){
            if(detector_groups[i].name == detector_0.group.name && detector_groups[j].name == detector_1.group.name){
                histogram_name = detector_0.group.name + "_" + detector_1.group.name;
                histogram_name_matched = true;
                break;
            }
            if(detector_groups[i].name == detector_1.group.name && detector_groups[j].name == detector_0.group.name){
                histogram_name = detector_1.group.name + "_" + detector_0.group.name;
                histogram_name_matched = true;
                break;
            }
        }
        if(histogram_name_matched){
            break;
        }
    }

    return histogram_name;
}

string energy_deposition_in_detector(const Detector detector, const string indent = ""){
    string ene_dep = "";
    for(size_t n_channel = 0; n_channel < detector.channels.size()-1; ++n_channel){
        ene_dep = ene_dep + "!isnan(" + detector.channels[n_channel].energy_branch_name + "[" + to_string(detector.channels[n_channel].energy_branch_index) + "]) || ";
    }
    ene_dep = ene_dep + "!isnan(" + detector.channels[detector.channels.size()-1].energy_branch_name + "[" + to_string(detector.channels[detector.channels.size()-1].energy_branch_index) + "])";

    return ene_dep;
}

string calibration_expression(const string variable, const vector<double> calibration_parameters){
    stringstream cal_exp;
    bool first_nonzero_term = true;

    for(size_t i = 0; i < calibration_parameters.size(); ++i){
        if(calibration_parameters[i] != 0.){
            if(first_nonzero_term){
                first_nonzero_term = false;
            } else {
                cal_exp << " + ";
            }
            if(calibration_parameters[i] != 1.){
                cal_exp << scientific << calibration_parameters[i];
            }
            for(size_t j = 0; j < i; ++j){
                if(calibration_parameters[i] == 1. && j == 0){
                    cal_exp << variable;
                } else {
                    cal_exp << " * " << variable;
                }
            }
        }
    }

    return cal_exp.str();
}

string calibrate_if_not_nan(const string variable, const vector<double> calibration_parameters, const string return_value_if_nan="0."){
    stringstream cal_exp;

    cal_exp << "isnan(" << variable << ") ? " << return_value_if_nan << " : " << calibration_expression(variable, calibration_parameters);

    return cal_exp.str();
}

string addback_expression(const Detector detector, const string addback_energy_array, const string maximum_energy_deposition_pointer, const string indent = ""){
    string add_bck_exp = "";
    for(size_t n_c = 0; n_c < detector.channels.size(); ++n_c){
        add_bck_exp = add_bck_exp + indent + addback_energy_array + "[" + to_string(n_c) + "] = " + calibrate_if_not_nan(energy_branch(detector.channels[n_c]), {0., 1.}) + ";\n";
    }

    add_bck_exp = add_bck_exp + indent + maximum_energy_deposition_pointer + " = max_element(&" + addback_energy_array + "[0], &" + addback_energy_array + "[" + to_string(detector.channels.size()-1) + "]);\n";

    for(size_t n_c_0 = 0; n_c_0 < detector.channels.size(); ++n_c_0){
        add_bck_exp = add_bck_exp + indent + "if(" + maximum_energy_deposition_pointer + " - &" + addback_energy_array + "[0] == " + to_string(n_c_0) + "){\n";
    }

    return add_bck_exp;
}

string sum_over_array(const string array_variable, const size_t array_size, const size_t min_index = 0){
    string sum;

    sum = sum + array_variable + "[" + to_string(min_index) + "]";
    for(size_t i = min_index+1; i < array_size; ++i){
        sum = sum + " + " + array_variable + "[" + to_string(i) + "]";
    }

    return sum;
}